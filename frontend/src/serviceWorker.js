/* eslint-disable no-restricted-globals */
import { clientsClaim } from "workbox-core";
import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { CacheFirst } from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching.
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell.
registerRoute(
  ({ request, url }) => {
    // Exclude non-navigation requests
    if (request.mode !== "navigate") {
      return false;
    }

    // Exclude URLs starting with underscore (_)
    if (url.pathname.startsWith("/_")) {
      return false;
    }

    // Exclude URLs with file extensions
    if (url.pathname.match(/\.[^/]+$/)) {
      return false;
    }

    // Return true to indicate this is a navigation request
    return true;
  },
  async ({ event }) => {
    try {
      // Fetch the index.html from the PUBLIC_URL
      const cache = await caches.open("__appshell");
      const cachedResponse = await cache.match("/index.html");

      // If index.html is in cache, return it
      if (cachedResponse) {
        return cachedResponse;
      }

      // Otherwise, fetch the index.html from the network
      const response = await fetch(event.request);

      // Cache the fetched index.html for future use
      await cache.put(event.request, response.clone());

      // Return the fetched index.html
      return response;
    } catch (error) {
      // Handle fetch errors
      console.error("Error fetching app shell", error);
      throw error;
    }
  }
);

// Cache images with a CacheFirst strategy
registerRoute(
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.endsWith(".png"),
  new CacheFirst({
    cacheName: "images",
    plugins: [new ExpirationPlugin({ maxEntries: 50 })],
  })
);

self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});
